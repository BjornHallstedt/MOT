#ifndef NMSIMPLEX_CL
#define NMSIMPLEX_CL

/**
 * Author = Robbert Harms
 * Date = 2014-09-29
 * License = see hereunder
 * Maintainer = Robbert Harms
 * Email = robbert.harms@maastrichtuniversity.nl
 */

/*
 * Program: nmsimplex.c
 * Author : Michael F. Hutt
 * http://www.mikehutt.com
 * 11/3/97
 *
 * An implementation of the Nelder-Mead simplex method.
 *
 * Copyright (c) 1997-2011 <Michael F. Hutt>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 * Jan. 6, 1999
 * Modified to conform to the algorithm presented
 * in Margaret H. Wright's paper on Direct Search Methods.
 *
 * Jul. 23, 2007
 * Fixed memory leak.
 *
 * Mar. 1, 2011
 * Added constraints. (Which were removed by Robbert in 2014, since we already have parameter transforms.)
 */

#define PATIENCE %(PATIENCE)r                  /* Used to set the maximum number of iterations
                                                   to patience * (number_of_parameters + 1). */
#define MAX_IT (PATIENCE * (%(NMR_PARAMS)r+1))
#define ALPHA       %(ALPHA)r                   /* reflection coefficient, default 1 */
#define BETA        %(BETA)r                    /* contraction coefficient, default 0.5 */
#define GAMMA       %(GAMMA)r                   /* expansion coefficient default 2 */
#define DELTA       %(DELTA)r                   /* reduction coefficient default 0.5 */
#define EPSILON     30*MOT_EPSILON              /** the precision we break at*/

int _nmsimplex(MOT_FLOAT_TYPE* const model_parameters, const void* const data, MOT_FLOAT_TYPE* const minf,
               MOT_FLOAT_TYPE* const simplex_scale, MOT_FLOAT_TYPE* const f_diff);

int nmsimplex(MOT_FLOAT_TYPE* const model_parameters, const void* const data){
    /** the minimum value at the initial simplex */
    MOT_FLOAT_TYPE minf = evaluate(model_parameters, data);

    /** the scale of the initial simplex, should be set by python code as a string: {v1, v2, ...} */
    MOT_FLOAT_TYPE simplex_scale[%(NMR_PARAMS)r] = %(INITIAL_SIMPLEX_SCALES)s;

    /** the difference between the high and low function values of the vertices */
    MOT_FLOAT_TYPE f_diff;

    return _nmsimplex(model_parameters, data, &minf, &simplex_scale, &f_diff);
}

/**
 * Internal routine for the Nelder Mead Simplex optimization routine.
 *
 * Args:
 *  model_parameters (array): On input the initial array of model parameters.
 *                            On output the location of the optimum found
 *  data (struct): the data struct we pass to the optimizer
 *  minf (double pointer): the minimum value of the initial model parameters.
 *      This saves evaluations when this function is used in SubPlex.
 *  simplex_scale (array): per parameter the scale (initial step size)
 *  f_diff (double): On output, this will contain the difference between the high and low function values
 *      of the last simplex.
 */
int _nmsimplex(MOT_FLOAT_TYPE* const model_parameters, const void* const data, MOT_FLOAT_TYPE* const minf,
               MOT_FLOAT_TYPE* const simplex_scale, MOT_FLOAT_TYPE* const f_diff){

    int return_code = 6; /** the default return code is that we exhausted our patience */
	int vs;         /* vertex with smallest value */
	int vh;         /* vertex with next smallest value */
	int vg;         /* vertex with largest value */
    int i, j;        /** helper variables */
	int itr;	      /* track the number of iterations */
	double tmp;
	MOT_FLOAT_TYPE fr;      /* value of function at reflection point */
	MOT_FLOAT_TYPE fe;   /* value of function at expansion point */
	MOT_FLOAT_TYPE fc;      /* value of function at contraction point */
	MOT_FLOAT_TYPE vertices[%(NMR_PARAMS)r + 1][%(NMR_PARAMS)r];     /* holds vertices of simplex */
    MOT_FLOAT_TYPE func_vals[%(NMR_PARAMS)r + 1]; /* value of function at each vertex */
    MOT_FLOAT_TYPE vr[%(NMR_PARAMS)r]; /* reflection - coordinates */
    MOT_FLOAT_TYPE ve_vc[%(NMR_PARAMS)r]; /* expansion - coordinates, & contraction - coordinates,
     										 that is, we use this variable at two points for different purposes.*/
    MOT_FLOAT_TYPE vm[%(NMR_PARAMS)r]; /* centroid - coordinates */

    /*
     * Create the initial simplex.
	 * We assume one of the vertices is 0,0
	 * Furthermore we set x_0 = x_input to allow for proper restarts.
	 */
	for (i=0;i<%(NMR_PARAMS)r;i++) {
		vertices[0][i] = model_parameters[i];
	}
	for (i=1;i<=%(NMR_PARAMS)r;i++) {
		for (j=0;j<%(NMR_PARAMS)r;j++) {
			vertices[i][j] = sqrt(%(NMR_PARAMS)r + 1.0) - 1;
			if (i-1 == j){
			    vertices[i][j] += %(NMR_PARAMS)r;
			}
            vertices[i][j] /= (%(NMR_PARAMS)r * sqrt(2.0));
            /** vertices now contains the unit vector e_j in R^n. */

            /** set x_j = x_input + h_j * e_j */
            vertices[i][j] = model_parameters[j] + simplex_scale[i-1] * vertices[i][j];
		}
	}

	/* find the initial function values */
	func_vals[0] = *minf;
	for (j=1;j<=%(NMR_PARAMS)r;j++) {
		func_vals[j] = evaluate(vertices[j], data);
	}

	/* begin the main loop of the minimization */
	for (itr=1;itr<=MAX_IT;itr++) {
		/* find the index of the largest and smallest value */
		vg=0;
		vs=0;
		for (j=0;j<=%(NMR_PARAMS)r;j++) {
            /* find largest */
			if (func_vals[j] > func_vals[vg]) {
				vg = j;
			}

		    /* find smallest */
			if (func_vals[j] < func_vals[vs]) {
				vs = j;
			}
		}

        /** store the difference between the largest and smallest function values */
        *f_diff = func_vals[vg] - func_vals[vs];

		/* find the index of the second largest value */
		vh=vs;
		for (j=0;j<=%(NMR_PARAMS)r;j++) {
			if (func_vals[j] > func_vals[vh] && func_vals[j] < func_vals[vg]) {
				vh = j;
			}
		}

		/* calculate the centroid */
		for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
			tmp=0.0;
			for (i=0;i<=%(NMR_PARAMS)r;i++) {
				if (i!=vg) {
					tmp += vertices[i][j];
				}
			}
			vm[j] = tmp/%(NMR_PARAMS)r;
		}

		/* reflect vg to new vertex vr */
		for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
			vr[j] = vm[j] + ALPHA * (vm[j] - vertices[vg][j]);
		}
		fr = evaluate(vr, data);

		if (fr < func_vals[vh] && fr >= func_vals[vs]) {
			for (j=0; j <= %(NMR_PARAMS)r-1; j++){
				vertices[vg][j] = vr[j];
			}
			func_vals[vg] = fr;
		}

		/* investigate a step further in this direction */
		if(fr < func_vals[vs]){
			for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
				/** ve_vc here used as ve */
				ve_vc[j] = vm[j] + GAMMA * (vr[j] - vm[j]);
			}

			fe = evaluate(ve_vc, data);
			if (fe < fr){
				for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
					vertices[vg][j] = ve_vc[j];
				}
				func_vals[vg] = fe;
			}
			else {
				for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
					vertices[vg][j] = vr[j];
				}
				func_vals[vg] = fr;
			}
		}

		/* check to see if a contraction is necessary */
		if (fr >= func_vals[vh]) {
			if (fr < func_vals[vg] && fr >= func_vals[vh]) {
				/* perform outside contraction */
				for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
					/** ve_vc here used as vc */
					ve_vc[j] = vm[j] + BETA * (vr[j]-vm[j]);
				}
			}
			else {
				/* perform inside contraction */
				for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
					ve_vc[j] = vm[j] - BETA * (vm[j] - vertices[vg][j]);
				}
			}

			fc = evaluate(ve_vc, data);
			if (fc < func_vals[vg]) {
				for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
					vertices[vg][j] = ve_vc[j];
				}
				func_vals[vg] = fc;
			}
			else {
                /* at this point the contraction is not successful,
                   we must reduce (by default halve) the distance from vs to all the
                   vertices of the simplex and then continue.
                */
				for (i=0;i<=%(NMR_PARAMS)r;i++) {
					if (i != vs) {
						for (j=0;j<=%(NMR_PARAMS)r-1;j++) {
							vertices[i][j] = vertices[vs][j] + (vertices[i][j]-vertices[vs][j]) * DELTA;
						}
					}
				}

				func_vals[vg] = evaluate(vertices[vg], data);
				func_vals[vh] = evaluate(vertices[vh], data);
			}
		}

		/* test for convergence */
		tmp = 0.0;
		for (j=0;j<=%(NMR_PARAMS)r;j++) {
			tmp += func_vals[j];
		}
		/** fr here used as tmp dummy */
		fr = tmp/(%(NMR_PARAMS)r+1);

		tmp = 0.0;
		for (j=0;j<=%(NMR_PARAMS)r;j++) {
			tmp += pown((func_vals[j]-fr), 2) / (%(NMR_PARAMS)r);
		}
		tmp = sqrt(tmp);

		if (tmp < EPSILON){
		    return_code = 1;
		    break;
		}
	}
	/* end main loop of the minimization */

	/* find the index of the largest and smallest value */
	vs = 0;
	for (j=0;j<=%(NMR_PARAMS)r;j++) {
		/* find smallest */
        if (func_vals[j] < func_vals[vs]) {
            vs = j;
        }
	}

    for (j=0;j<%(NMR_PARAMS)r;j++) {
		model_parameters[j] = vertices[vs][j];
	}

	return return_code;
}

#undef PATIENCE
#undef MAX_IT
#undef ALPHA
#undef BETA
#undef GAMMA
#undef EPSILON

#endif // NMSIMPLEX_CL
