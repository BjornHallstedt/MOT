#ifndef LMMIN_CL
#define LMMIN_CL

/*
 * Library:   lmfit (Levenberg-Marquardt least squares fitting)
 * File:      lmmin.c
 * Contents:  Levenberg-Marquardt minimization.
 * Copyright: MINPACK authors, The University of Chikago (1980-1999)
 *            Joachim Wuttke, Forschungszentrum Juelich GmbH (2004-2013)
 *            Robbert Harms (2013)
 * License:   see ../COPYING (FreeBSD)
 * Homepage:  apps.jcns.fz-juelich.de/lmfit
 */

/**
 * Adapted by = Robbert Harms
 * Date = 2014-02-05
 * License = LGPL v3
 * Maintainer = Robbert Harms
 * Email = robbert.harms@maastrichtuniversity.nl
 */

/* function declarations. */
void lm_lmpar( int n, optimizer_float * const r, int ldr, int * const ipvt, optimizer_float *const diag,
               optimizer_float * const qtb, optimizer_float delta, optimizer_float * const par, optimizer_float * const x,
               optimizer_float * const sdiag, optimizer_float * const aux, optimizer_float * const xdi );
void lm_qrfac( int m, int n, optimizer_float * const a, int * const ipvt,
               optimizer_float * const rdiag, optimizer_float * const acnorm, optimizer_float * const wa );
void lm_qrsolv( int n, optimizer_float * const r, int ldr, int * const ipvt, optimizer_float * const diag,
                optimizer_float * const qtb, optimizer_float * const x, optimizer_float * const sdiag, optimizer_float * const wa );
optimizer_float lm_euclidian_norm(const optimizer_float* const x, const int n);

/*****************************************************************************/
/*  Numeric constants                                                        */
/*****************************************************************************/

/* machine-dependent constants from float.h */
#define LM_MACHEP     EPSILON_OPTIMIZER_FLOAT   /* resolution of arithmetic */
#define LM_DWARF      MIN_OPTIMIZER_FLOAT       /* smallest nonzero number */
#define LM_SQRT_DWARF sqrt(MIN_OPTIMIZER_FLOAT) /* square should not underflow */
#define LM_SQRT_GIANT sqrt(MAX_OPTIMIZER_FLOAT) /* square should not overflow */
#define LM_USERTOL    30*LM_MACHEP  /* users are recommended to require this */

#define FTOL LM_USERTOL      /* Relative error desired in the sum of squares.
                             Termination occurs when both the actual and
                             predicted relative reductions in the sum of squares
                             are at most ftol. */
#define XTOL LM_USERTOL      /* Relative error between last two approximations.
                             Termination occurs when the relative error between
                             two consecutive iterates is at most xtol. */
#define GTOL LM_USERTOL      /* Orthogonality desired between fvec and its derivs.
                             Termination occurs when the cosine of the angle
                             between fvec and any column of the Jacobian is at
                             most gtol in absolute value. */
#define EPSILON LM_USERTOL   /* Step used to calculate the Jacobian, should be
                             slightly larger than the relative error in the
                             user-supplied functions. */
#define STEP_BOUND 100.0     /* Used in determining the initial step bound. This
                             bound is set to the product of stepbound and the
                             Euclidean norm of diag*x if nonzero, or else to
                             stepbound itself. In most cases stepbound should lie
                             in the interval (0.1,100.0). Generally, the value
                             100.0 is recommended. */
#define PATIENCE %(PATIENCE)r /* Used to set the maximum number of function evaluations
                             to patience*(number_of_parameters+1). */
#define SCALE_DIAG 0        /* If 1, the variables will be rescaled internally.
                             Recommended value is 1. */
#define MAXFEV (PATIENCE * (%(NMR_PARAMS)s+1)) /** the maximum number of evaluations */
#define EPS sqrt(max(EPSILON, LM_MACHEP)) /* for forward differences */
#define LMPAR_P1 0.1 /** parameter p1 from the lmpar function */
#define LM_ENORM_SQRT_GIANT sqrt(MAX_OPTIMIZER_FLOAT) /* square should not overflow */
#define LM_ENORM_SQRT_DWARF sqrt(MIN_OPTIMIZER_FLOAT) /* square should not underflow */

/** 
 * The function furthermore requires you to define:
 * #define NMR_INST_PER_PROBLEM         | as the number of instances per problem (m)
 */

/**
 * Make sure that the following holds:
 * %(NMR_PARAMS)s > 0
 * NMR_INST_PER_PROBLEM >= %(NMR_PARAMS)s
 * FTOL >= 0. && XTOL >= 0. && GTOL >= 0.
 * MAXFEV > 0
 * STEP_BOUND > 0.
 * SCALE_DIAG == 0 || SCALE_DIAG == 1
 */

/*****************************************************************************/
/*  lmmin (main minimization routine)                                        */
/*****************************************************************************/

/**
 * x: starting parameters
 * data: a struct holding all the data necessary for fitting
 * n: the parameter length (the number of variables to optimize)
 * m: the number of instances per problem. It must fulfill m>=n
 *
 * void evaluate(const void* data, optimizer_float* x, optimizer_float* result);
 *
 */

void lmmin(optimizer_float * const x, const void* const data){
	
	int j, i;
    optimizer_float actred, dirder, fnorm, fnorm1, gnorm, pnorm, prered, ratio, step, sum, temp, temp1, temp2, temp3;

    bool   done_first = false;  /* loop counters, for monitoring */
    bool   inner_success; /* flag for loop control */
    optimizer_float lmpar = 0;     /* Levenberg-Marquardt parameter */
    optimizer_float delta = 0;
    optimizer_float xnorm = 0;
	int nfev = 0;

	/***  Allocate work space.  ***/
    optimizer_float fvec[NMR_INST_PER_PROBLEM];
    optimizer_float diag[%(NMR_PARAMS)s];
    optimizer_float qtf[%(NMR_PARAMS)s];
    optimizer_float fjac[%(NMR_PARAMS)s * NMR_INST_PER_PROBLEM];
    optimizer_float wa1[%(NMR_PARAMS)s];
    optimizer_float wa2[%(NMR_PARAMS)s];
    optimizer_float wa3[%(NMR_PARAMS)s];
    optimizer_float wf[NMR_INST_PER_PROBLEM];
    int ipvt[%(NMR_PARAMS)s];

    if (!SCALE_DIAG) {
        for (j = 0; j < %(NMR_PARAMS)s; j++)
            diag[j] = 1.;
    }
	
	/***  Evaluate function at starting point and calculate norm.  ***/
    evaluate(data, x, fvec);
    ++nfev;
    fnorm = lm_euclidian_norm(fvec, NMR_INST_PER_PROBLEM);
    if( fnorm <= LM_DWARF ){
        return;
    }
    
    ///***  The outer loop: compute gradient, then descend.  ***/
    while(true){
		/***  [outer]  Calculate the Jacobian.  ***/
        for (j = 0; j < %(NMR_PARAMS)s; j++) {
            temp = x[j];
            step = max(EPS*EPS, EPS * fabs(temp));
            x[j] += step; /* replace temporarily */
            evaluate(data, x, wf);
            ++nfev;
            for (i = 0; i < NMR_INST_PER_PROBLEM; i++){
                fjac[j*NMR_INST_PER_PROBLEM+i] = (wf[i] - fvec[i]) / step;
            }
            x[j] = temp; /* restore */
        }
        
		/***  [outer]  Compute the QR factorization of the Jacobian.  ***/

		/*      fjac is an m by n array. The upper n by n submatrix of fjac 
		 *        is made to contain an upper triangular matrix r with diagonal
		 *        elements of nonincreasing magnitude such that
		 *
		 *              p^T*(jac^T*jac)*p = r^T*r
		 *
		 *              (NOTE: ^T stands for matrix transposition),
		 *
		 *        where p is a permutation matrix and jac is the final calculated
		 *        Jacobian. Column j of p is column ipvt(j) of the identity matrix.
		 *        The lower trapezoidal part of fjac contains information generated
		 *        during the computation of r.
		 *
		 *      ipvt is an integer array of length n. It defines a permutation
		 *        matrix p such that jac*p = q*r, where jac is the final calculated
		 *        Jacobian, q is orthogonal (not stored), and r is upper triangular
		 *        with diagonal elements of nonincreasing magnitude. Column j of p
		 *        is column ipvt(j) of the identity matrix.
		 */
		lm_qrfac(NMR_INST_PER_PROBLEM, %(NMR_PARAMS)s, fjac, ipvt, wa1, wa2, wa3);
        /* return values are ipvt, wa1=rdiag, wa2=acnorm */

		/***  [outer]  Form q^T * fvec and store first n components in qtf.  ***/
        for (i = 0; i < NMR_INST_PER_PROBLEM; i++){
            wf[i] = fvec[i];
		}

        for(j = 0; j < %(NMR_PARAMS)s; j++){
            temp3 = fjac[j*NMR_INST_PER_PROBLEM+j];
            if (temp3 != 0.) {
                sum = 0;
                for (i = j; i < NMR_INST_PER_PROBLEM; i++){
                    sum += fjac[j*NMR_INST_PER_PROBLEM+i] * wf[i];
				}
                temp = -sum / temp3;
                for (i = j; i < NMR_INST_PER_PROBLEM; i++){
                    wf[i] += fjac[j*NMR_INST_PER_PROBLEM+i] * temp;
				}
            }
            fjac[j*NMR_INST_PER_PROBLEM+j] = wa1[j];
            qtf[j] = wf[j];
        }

		/***  [outer]  Compute norm of scaled gradient and detect degeneracy.  ***/
        gnorm = 0;
        for (j = 0; j < %(NMR_PARAMS)s; j++) {
            if(wa2[ipvt[j]] != 0){
                sum = 0.0;
                for (i = 0; i <= j; i++){
                    sum += fjac[j*NMR_INST_PER_PROBLEM+i] * qtf[i];
                }
                gnorm = max( gnorm, fabs( sum / wa2[ipvt[j]] / fnorm ) );
            }
        }

        if (gnorm <= GTOL) {
            return;
        }

		/***  [outer]  Initialize / update diag and delta. ***/
		if(!done_first){
            /* first iteration only */
            if (SCALE_DIAG) {
                /* diag := norms of the columns of the initial Jacobian */
                for (j = 0; j < %(NMR_PARAMS)s; j++){
                    if(wa2[j]){
                        diag[j] = wa2[j];
                    }
                    else{
                        diag[j] = 1;   
                    }
                }
                /* xnorm := || D x || */
                for (j = 0; j < %(NMR_PARAMS)s; j++){
                    wa3[j] = diag[j] * x[j];
                }
                xnorm = lm_euclidian_norm(wa3, %(NMR_PARAMS)s);
            } else {
                xnorm = lm_euclidian_norm(x, %(NMR_PARAMS)s);
            }
            /* initialize the step bound delta. */
            if(xnorm){
                delta = STEP_BOUND * xnorm;
            }
            else{
                delta = STEP_BOUND;
            }
        } else {
            if (SCALE_DIAG) {
                for (j = 0; j < %(NMR_PARAMS)s; j++){
                    diag[j] = max( diag[j], wa2[j] );
                }
            }
        }

		/***  The inner loop. ***/
        do {
			/***  [inner]  Determine the Levenberg-Marquardt parameter.  ***/
			lm_lmpar(%(NMR_PARAMS)s, fjac, NMR_INST_PER_PROBLEM, ipvt, diag, qtf, delta, &lmpar, wa1, wa2, wf, wa3 );
            /* used return values are fjac (partly), lmpar, wa1=x, wa3=diag*x */

            /* predict scaled reduction */
            pnorm = lm_euclidian_norm(wa3, %(NMR_PARAMS)s);
            temp2 = lmpar * pown( pnorm / fnorm, 2);
            for (j = 0; j < %(NMR_PARAMS)s; j++) {
                wa3[j] = 0;
                for (i = 0; i <= j; i++){
                    wa3[i] -= fjac[j*NMR_INST_PER_PROBLEM+i] * wa1[ipvt[j]];
				}
            }
            temp1 = pown( lm_euclidian_norm(wa3, %(NMR_PARAMS)s) / fnorm , 2);
            prered = temp1 + 2 * temp2;
            dirder = -temp1 + temp2; /* scaled directional derivative */

            /* at first call, adjust the initial step bound. */
            if ( !done_first && pnorm < delta ){
                delta = pnorm;
			}

			/***  [inner]  Evaluate the function at x + p.  ***/
			for (j = 0; j < %(NMR_PARAMS)s; j++){
                wa2[j] = x[j] - wa1[j];
			}
            
            evaluate(data, wa2, wf);
            ++nfev;
            fnorm1 = lm_euclidian_norm(wf, NMR_INST_PER_PROBLEM);

			/***  [inner]  Evaluate the scaled reduction.  ***/
			/* actual scaled reduction */
            actred = 1 - pown(fnorm1/fnorm, 2);

            /* ratio of actual to predicted reduction */
            if(prered){
                ratio = actred/prered;
            }
            else{
                ratio = 0;
            }
            
            /* update the step bound */
            if( ratio <= 0.25 ) {
                if( actred >= 0 ){
                    temp = 0.5;
                }
                else if ( actred > -99 ){ /* -99 = 1-1/0.1^2 */
                    temp = max( dirder / (2*dirder + actred), (optimizer_float) 0.1 );
                }
                else{
                    temp = 0.1;
                }
                delta = temp * min(delta, (optimizer_float)(pnorm / 0.1));
                lmpar /= temp;
            }
            else if ( ratio >= 0.75 ) {
                delta = 2*pnorm;
                lmpar *= 0.5;
            }
            else if ( !lmpar ) {
                delta = 2*pnorm;
            }

			/***  [inner]  On success, update solution, and test for convergence.  ***/
			inner_success = ratio >= 1.0e-4;
            if ( inner_success ) {
				/* update x, fvec, and their norms */
                if (SCALE_DIAG) {
                    for (j = 0; j < %(NMR_PARAMS)s; j++) {
                        x[j] = wa2[j];
                        wa2[j] = diag[j] * x[j];
                    }
                } else {
                    for (j = 0; j < %(NMR_PARAMS)s; j++){
                        x[j] = wa2[j];
                    }
                }
                for (i = 0; i < NMR_INST_PER_PROBLEM; i++){
                    fvec[i] = wf[i];
                }
                xnorm = lm_euclidian_norm(wa2, %(NMR_PARAMS)s);
                fnorm = fnorm1;
            }

            /* convergence tests */ 
            if( fnorm<=LM_DWARF ){
                return; /* success: sum of squares almost zero */
            }
            
            /* test two criteria (both may be fulfilled) */
            if (fabs(actred) <= FTOL && prered <= FTOL && ratio <= 2){
				return; /* success: x almost stable */
			}
            if (delta <= XTOL * xnorm){
				return; /* success: sum of squares almost stable */
			}

			/***  [inner]  Tests for termination and stringent tolerances.  ***/
			if ( nfev >= MAXFEV ){
                return;
            }
            if ( fabs(actred) <= LM_MACHEP && prered <= LM_MACHEP && ratio <= 2 ){
                return;
            }
            if ( delta <= LM_MACHEP*xnorm ){
                return;
            }
            if ( gnorm <= LM_MACHEP ){
                return;
            }
			
			/***  [inner]  End of the loop. Repeat if iteration unsuccessful.  ***/
        } while ( !inner_success );

        done_first = true;
    };/***  [outer]  End of the loop. ***/ 
} /*** lmmin. ***/


/*****************************************************************************/
/*  lm_lmpar (determine Levenberg-Marquardt parameter)                       */
/*****************************************************************************/

void lm_lmpar(int n, optimizer_float * const r, int ldr, int * const ipvt, optimizer_float * const diag,
              optimizer_float * const qtb, optimizer_float delta, optimizer_float * const par, optimizer_float * const x,
              optimizer_float * const sdiag, optimizer_float * const aux, optimizer_float * const xdi)
{
/*     Given an m by n matrix a, an n by n nonsingular diagonal
 *     matrix d, an m-vector b, and a positive number delta,
 *     the problem is to determine a value for the parameter
 *     par such that if x solves the system
 *
 *          a*x = b  and  sqrt(par)*d*x = 0
 *
 *     in the least squares sense, and dxnorm is the euclidean
 *     norm of d*x, then either par=0 and (dxnorm-delta) < 0.1*delta,
 *     or par>0 and abs(dxnorm-delta) < 0.1*delta.
 *
 *     Using lm_qrsolv, this subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then lmpar expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of qT*b. On output
 *     lmpar also provides an upper triangular matrix s such that
 *
 *          p^T*(a^T*a + par*d*d)*p = s^T*s.
 *
 *     s is employed within lmpar and may be of separate interest.
 *
 *     Only a few iterations are generally needed for convergence
 *     of the algorithm. If, however, the limit of 10 iterations
 *     is reached, then the output par will contain the best
 *     value obtained so far.
 *
 *     parameters:
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. on input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        on OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      delta is a positive input variable which specifies an upper
 *        bound on the euclidean norm of d*x.
 *
 *      par is a nonnegative variable. on input par contains an
 *        initial estimate of the levenberg-marquardt parameter.
 *        on OUTPUT par contains the final estimate.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, sqrt(par)*d*x = 0,
 *        for the output par.
 *
 *      sdiag is an array of length n needed as workspace; on OUTPUT
 *        it contains the diagonal elements of the upper triangular matrix s.
 *
 *      aux is a multi-purpose work array of length n.
 *
 *      xdi is a work array of length n. On OUTPUT: diag[j] * x[j].
 *
 */
    // used as both iter and nsing
    int iter_nsing;
    int i, j;
    // used as both gnorm and parc
    optimizer_float gnorm_parc;
    optimizer_float dxnorm, fp, fp_old, parl, paru;
    optimizer_float temp;

/*** lmpar: compute and store in x the gauss-newton direction. if the
     jacobian is rank-deficient, obtain a least squares solution. ***/

    // used as nsing
    iter_nsing = n;
    for (j = 0; j < n; j++) {
        aux[j] = qtb[j];        
        if (r[j * ldr + j] == 0 && iter_nsing == n){
            iter_nsing = j;
        }
        if (iter_nsing < n){
            aux[j] = 0;
        }
    }
    for (j = iter_nsing - 1; j >= 0; j--) {
        aux[j] = aux[j] / r[j + ldr * j];
        temp = aux[j];
        for (i = 0; i < j; i++){
            aux[i] -= r[j * ldr + i] * temp;
        }
    }

    for (j = 0; j < n; j++){
        x[ipvt[j]] = aux[j];
    }

/*** lmpar: initialize the iteration counter, evaluate the function at the
     origin, and test for acceptance of the gauss-newton direction. ***/

    for (j = 0; j < n; j++){
        xdi[j] = diag[j] * x[j];
    }
    dxnorm = lm_euclidian_norm(xdi, n);
    fp = dxnorm - delta;
    if (fp <= LMPAR_P1 * delta) {
        *par = 0;
        return;
    }

/*** lmpar: if the jacobian is not rank deficient, the newton
     step provides a lower bound, parl, for the 0. of
     the function. otherwise set this bound to 0.. ***/

    parl = 0;
    if (iter_nsing >= n) {
        for (j = 0; j < n; j++){
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;
        }

        for (j = 0; j < n; j++) {
            temp = 0.;
            for (i = 0; i < j; i++){
                temp += r[j * ldr + i] * aux[i];
            }
            aux[j] = (aux[j] - temp) / r[j + ldr * j];
        }
        temp = lm_euclidian_norm(aux, n);
        parl = fp / delta / temp / temp;
    }

/*** lmpar: calculate an upper bound, paru, for the 0. of the function. ***/

    for (j = 0; j < n; j++) {
        temp = 0;
        for (i = 0; i <= j; i++){
            temp += r[j * ldr + i] * qtb[i];
        }
        aux[j] = temp / diag[ipvt[j]];
    }
    //used as gnorm
    gnorm_parc = lm_euclidian_norm(aux, n);
    paru = gnorm_parc / delta;
    if (paru == 0.){
        paru = LM_DWARF / min(delta, (optimizer_float)LMPAR_P1);
    }

/*** lmpar: if the input par lies outside of the interval (parl,paru),
     set par to the closer endpoint. ***/

    *par = max(*par, parl);
    *par = min(*par, paru);
    if (*par == 0.){
        *par = gnorm_parc / dxnorm;
    }

/*** lmpar: iterate. ***/
    // used as iter
    for (iter_nsing=0; ; iter_nsing++) {

        /** evaluate the function at the current value of par. **/

        if (*par == 0.){
            *par = max(LM_DWARF, (model_float)(0.001 * paru));
        }
        temp = sqrt(*par);
        for (j = 0; j < n; j++){
            aux[j] = temp * diag[j];
        }

        lm_qrsolv( n, r, ldr, ipvt, aux, qtb, x, sdiag, xdi );
        /* return values are r, x, sdiag */

        for (j = 0; j < n; j++){
            xdi[j] = diag[j] * x[j]; /* used as output */
        }
        dxnorm = lm_euclidian_norm(xdi, n);
        fp_old = fp;
        fp = dxnorm - delta;
        
        /** if the function is small enough, accept the current value
            of par. Also test for the exceptional cases where parl
            is zero or the number of iterations has reached 10. **/

        if (fabs(fp) <= LMPAR_P1 * delta
            || (parl == 0. && fp <= fp_old && fp_old < 0.)
            || iter_nsing == 10) {
            break; /* the only exit from the iteration. */
        }
        
        /** compute the Newton correction. **/
        for (j = 0; j < n; j++){
            aux[j] = diag[ipvt[j]] * xdi[ipvt[j]] / dxnorm;
        }

        for (j = 0; j < n; j++) {
            aux[j] = aux[j] / sdiag[j];
            for (i = j + 1; i < n; i++){
                aux[i] -= r[j * ldr + i] * aux[j];
            }
        }
        temp = lm_euclidian_norm(aux, n);
        // used as parc
        gnorm_parc = fp / delta / temp / temp;

        /** depending on the sign of the function, update parl or paru. **/

        if (fp > 0){
            parl = max(parl, *par);
        }
        else if (fp < 0){
            paru = min(paru, *par);
        }
        /* the case fp==0 is precluded by the break condition  */
        
        /** compute an improved estimate for par. **/
        
        *par = max(parl, *par + gnorm_parc);
        
    }

} /*** lm_lmpar. ***/


/*****************************************************************************/
/*  lm_qrfac (QR factorization, from lapack)                                 */
/*****************************************************************************/

void lm_qrfac(int m, int n, optimizer_float * const a, int * const ipvt,
              optimizer_float * const rdiag, optimizer_float * const acnorm, optimizer_float * const wa)
{
/*
 *     This subroutine uses Householder transformations with column
 *     pivoting (optional) to compute a qr factorization of the
 *     m by n matrix a. That is, qrfac determines an orthogonal
 *     matrix q, a permutation matrix p, and an upper trapezoidal
 *     matrix r with diagonal elements of nonincreasing magnitude,
 *     such that a*p = q*r. The Householder transformation for
 *     column k, k = 1,2,...,min(m,n), is of the form
 *
 *          i - (1/u(k))*u*uT
 *
 *     where u has zeroes in the first k-1 positions. The form of
 *     this transformation and the method of pivoting first
 *     appeared in the corresponding linpack subroutine.
 *
 *     Parameters:
 *
 *      m is a positive integer input variable set to the number
 *        of rows of a.
 *
 *      n is a positive integer input variable set to the number
 *        of columns of a.
 *
 *      a is an m by n array. On input a contains the matrix for
 *        which the qr factorization is to be computed. On OUTPUT
 *        the strict upper trapezoidal part of a contains the strict
 *        upper trapezoidal part of r, and the lower trapezoidal
 *        part of a contains a factored form of q (the non-trivial
 *        elements of the u vectors described above).
 *
 *      ipvt is an integer OUTPUT array of length lipvt. This array
 *        defines the permutation matrix p such that a*p = q*r.
 *        Column j of p is column ipvt(j) of the identity matrix.
 *
 *      rdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of r.
 *
 *      acnorm is an OUTPUT array of length n which contains the
 *        norms of the corresponding columns of the input matrix a.
 *        If this information is not needed, then acnorm can coincide
 *        with rdiag.
 *
 *      wa is a work array of length n.
 *
 */
    int i, j, k, kmax, minmn;
    optimizer_float ajnorm, temp;

/*** qrfac: compute initial column norms and initialize several arrays. ***/

    for (j = 0; j < n; j++) {
        acnorm[j] = lm_euclidian_norm(&a[j*m], m);
        rdiag[j] = acnorm[j];
        wa[j] = rdiag[j];
        ipvt[j] = j;
    }

/*** qrfac: reduce a to r with Householder transformations. ***/

    minmn = min(m, n);
    for (j = 0; j < minmn; j++) {

        /** bring the column of largest norm into the pivot position. **/
        kmax = j;
        for (k = j + 1; k < n; k++)
            if (rdiag[k] > rdiag[kmax])
                kmax = k;
        
        if (kmax != j){
            for (i = 0; i < m; i++) {
                temp = a[j*m+i];
                a[j*m+i] = a[kmax*m+i];
                a[kmax*m+i] = temp;
            }
            rdiag[kmax] = rdiag[j];
            wa[kmax] = wa[j];
            k = ipvt[j];
            ipvt[j] = ipvt[kmax];
            ipvt[kmax] = k;
        }       


        /** compute the Householder transformation to reduce the
            j-th column of a to a multiple of the j-th unit vector. **/
        ajnorm = lm_euclidian_norm(&a[j*m+j], m-j);
        if (ajnorm == 0.) {
            rdiag[j] = 0;
        }
        else{
            if (a[j*m+j] < 0.){
                ajnorm = -ajnorm;
            }
            for (i = j; i < m; i++){
                a[j*m+i] /= ajnorm;
            }
            a[j*m+j] += 1;

            /** apply the transformation to the remaining columns
                and update the norms. **/
            for (k = j + 1; k < n; k++){
                temp = 0;

                for (i = j; i < m; i++){
                    temp += a[j*m+i] * a[k*m+i];
                }

                temp = temp / a[j + m * j];

                for (i = j; i < m; i++){
                    a[k*m+i] -= temp * a[j*m+i];
                }

                if (rdiag[k] != 0.) {
                    temp = a[m * k + j] / rdiag[k];
                    temp = max((optimizer_float)0. , 1 - temp * temp);
                    rdiag[k] *= sqrt(temp);
                    temp = rdiag[k] / wa[k];
                    if ( 0.05 * pown(temp, 2) <= LM_MACHEP ) {
                        rdiag[k] = lm_euclidian_norm(&a[m*k+j+1], m-j-1);
                        wa[k] = rdiag[k];
                    }
                }
            }

            rdiag[j] = -ajnorm;
        }
    }
} /*** lm_qrfac. ***/


/*****************************************************************************/
/*  lm_qrsolv (linear least-squares)                                         */
/*****************************************************************************/

void lm_qrsolv(int n, optimizer_float * const r, int ldr, int * const ipvt, optimizer_float * const diag,
               optimizer_float * const qtb, optimizer_float * const x, optimizer_float * const sdiag, optimizer_float * const wa)
{
/*
 *     Given an m by n matrix a, an n by n diagonal matrix d,
 *     and an m-vector b, the problem is to determine an x which
 *     solves the system
 *
 *          a*x = b  and  d*x = 0
 *
 *     in the least squares sense.
 *
 *     This subroutine completes the solution of the problem
 *     if it is provided with the necessary information from the
 *     qr factorization, with column pivoting, of a. That is, if
 *     a*p = q*r, where p is a permutation matrix, q has orthogonal
 *     columns, and r is an upper triangular matrix with diagonal
 *     elements of nonincreasing magnitude, then qrsolv expects
 *     the full upper triangle of r, the permutation matrix p,
 *     and the first n components of (q transpose)*b. The system
 *     a*x = b, d*x = 0, is then equivalent to
 *
 *          r*z = q^T*b,  p^T*d*p*z = 0,
 *
 *     where x = p*z. If this system does not have full rank,
 *     then a least squares solution is obtained. On output qrsolv
 *     also provides an upper triangular matrix s such that
 *
 *          p^T *(a^T *a + d*d)*p = s^T *s.
 *
 *     s is computed within qrsolv and may be of separate interest.
 *
 *     Parameters
 *
 *      n is a positive integer input variable set to the order of r.
 *
 *      r is an n by n array. On input the full upper triangle
 *        must contain the full upper triangle of the matrix r.
 *        On OUTPUT the full upper triangle is unaltered, and the
 *        strict lower triangle contains the strict upper triangle
 *        (transposed) of the upper triangular matrix s.
 *
 *      ldr is a positive integer input variable not less than n
 *        which specifies the leading dimension of the array r.
 *
 *      ipvt is an integer input array of length n which defines the
 *        permutation matrix p such that a*p = q*r. Column j of p
 *        is column ipvt(j) of the identity matrix.
 *
 *      diag is an input array of length n which must contain the
 *        diagonal elements of the matrix d.
 *
 *      qtb is an input array of length n which must contain the first
 *        n elements of the vector (q transpose)*b.
 *
 *      x is an OUTPUT array of length n which contains the least
 *        squares solution of the system a*x = b, d*x = 0.
 *
 *      sdiag is an OUTPUT array of length n which contains the
 *        diagonal elements of the upper triangular matrix s.
 *
 *      wa is a work array of length n.
 *
 */
    int i, kk, j, k;
    optimizer_float qtbpj, temp;
    optimizer_float _sin, _cos, _tan, _cot; /* local variables, not functions */

/*** qrsolv: copy r and q^T*b to preserve input and initialize s.
     in particular, save the diagonal elements of r in x. ***/

    for (j = 0; j < n; j++) {
        for (i = j; i < n; i++)
            r[j * ldr + i] = r[i * ldr + j];
        x[j] = r[j * ldr + j];
        wa[j] = qtb[j];
    }
/*** qrsolv: eliminate the diagonal matrix d using a Givens rotation. ***/

    for (j = 0; j < n; j++) {

/*** qrsolv: prepare the row of d to be eliminated, locating the
     diagonal element using p from the qr factorization. ***/

        if (diag[ipvt[j]] != 0.){
            for (k = j; k < n; k++)
                sdiag[k] = 0.;
            sdiag[j] = diag[ipvt[j]];
    
    /*** qrsolv: the transformations to eliminate the row of d modify only 
         a single element of qT*b beyond the first n, which is initially 0. ***/
    
            qtbpj = 0.;
            for (k = j; k < n; k++) {
    
                /** determine a Givens rotation which eliminates the
                    appropriate element in the current row of d. **/
                if (sdiag[k] != 0.){
                    kk = k + ldr * k;
                    if (fabs(r[kk]) < fabs(sdiag[k])) {
                        _cot = r[kk] / sdiag[k];
                        _sin = 1 / sqrt(1 + pown(_cot, 2));
                        _cos = _sin * _cot;
                    } else {
                        _tan = sdiag[k] / r[kk];
                        _cos = 1 / sqrt(1 + pown(_tan, 2));
                        _sin = _cos * _tan;
                    }

                    /** compute the modified diagonal element of r and
                        the modified element of ((q^T)*b,0). **/

                    r[kk] = _cos * r[kk] + _sin * sdiag[k];
                    temp = _cos * wa[k] + _sin * qtbpj;
                    qtbpj = -_sin * wa[k] + _cos * qtbpj;
                    wa[k] = temp;

                    /** accumulate the tranformation in the row of s. **/
                    for (i = k + 1; i < n; i++) {
                        temp = _cos * r[k * ldr + i] + _sin * sdiag[i];
                        sdiag[i] = -_sin * r[k * ldr + i] + _cos * sdiag[i];
                        r[k * ldr + i] = temp;
                    }
                }
            }
        }
        /** store the diagonal element of s and restore
            the corresponding diagonal element of r. **/

        sdiag[j] = r[j * ldr + j];
        r[j * ldr + j] = x[j];
    }

/*** qrsolv: solve the triangular system for z. if the system is
     singular, then obtain a least squares solution. ***/

    // use k below as nsing
    k = n;
    for (j = 0; j < n; j++) {
        if (sdiag[j] == 0. && k == n){
            k = j;
        }
        if (k < n){
            wa[j] = 0;
        }
    }

    for (j = k - 1; j >= 0; j--) {
        temp = 0.;
        for (i = j + 1; i < k; i++){
            temp += r[j * ldr + i] * wa[i];
        }
        wa[j] = (wa[j] - temp) / sdiag[j];
    }

/*** qrsolv: permute the components of z back to components of x. ***/

    for (j = 0; j < n; j++){
        x[ipvt[j]] = wa[j];
    }

} /*** lm_qrsolv. ***/


/*****************************************************************************/
/*  euclidian_norm (Euclidean norm)                                          */
/*****************************************************************************/
optimizer_float lm_euclidian_norm(const optimizer_float* const x, const int n){
/*     Given an n-vector x, this function calculates the
 *     euclidean norm of x.
 *
 *     Parameters
 *
 *      n is a positive integer input variable.
 *
 *      x is an input array of length n.
 */
    double sum = 0.0;
    for(int i = 0; i < n; i++){
        sum += pown(x[i], 2);
    }
    return (optimizer_float) sqrt(sum);

} /*** euclidian_norm. ***/

#undef LM_MACHEP
#undef LM_DWARF
#undef LM_SQRT_DWARF
#undef LM_SQRT_GIANT
#undef LM_USERTOL
#undef FTOL
#undef XTOL
#undef GTOL
#undef EPSILON
#undef STEP_BOUND
#undef PATIENCE
#undef SCALE_DIAG
#undef MAXFEV
#undef EPS
#undef LMPAR_P1
#undef LM_ENORM_SQRT_GIANT
#undef LM_ENORM_SQRT_DWARF

#endif // LMMIN_CL
